<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>OpenAI 开发者论坛 - 最新帖子</title>
    <link>https://community.openai.com</link>
    <description>最新帖子</description>
    <lastBuildDate>Thu, 18 Jan 2024 09:19:20 GMT</lastBuildDate>
    <item>
      <title>从 Assistant API 切换到人工代理</title>
      <link>https://community.openai.com/t/switching-from-assistant-api-to-human-agents/591801#post_1</link>
      <description><![CDATA[您好，正如主题所述，有关如何将机器人会话从机器人（助理 API）切换到人工代理的任何建议或工作流程。这里有人实施过这样的解决方案吗？]]></description>
      <guid>https://community.openai.com/t/switching-from-assistant-api-to-human-agents/591801#post_1</guid>
      <pubDate>Thu, 18 Jan 2024 09:09:44 GMT</pubDate>
    </item>
    <item>
      <title>Assistant API - 计费计算中的上下文令牌是什么？</title>
      <link>https://community.openai.com/t/assistant-api-what-are-context-tokens-in-the-billing-calculation/497675#post_19</link>
      <description><![CDATA[我确认上述观察结果和挫败感：

我从 12 月初开始使用 Assistants API，首先没有代码解释器，也没有检索。我每天的费用不到 2 美元，而且没有问自己任何问题
12 月中旬，我开始使用检索并添加 1 个 10 页/2000 字的 pdf 文件。从那时起，我每天的费用从 2 美元到 20 美元不等。

自从我使用“检索”后，每日清理费用的平均水平有所上升，但我发现每日费用与我使用 Google 助理的次数之间没有直接联系。感觉很随意。昨天我的峰值使用量为 20 美元（这就是我突然开始研究这个的原因），但我不知道为什么。
当我查看“我的活动”时，高成本都与这些神秘的“上下文标记”有关。
在测试版模式下发布某些东西，如果还好的话仍然存在一些问题，但通过向测试人员收取与正常成本相比难以解释的高额费用而从中受益，而没有任何警告/文档/沟通，这是一个骗局。]]></description>
      <guid>https://community.openai.com/t/assistant-api-what-are-context-tokens-in-the-billing-calculation/497675#post_19</guid>
      <pubDate>Thu, 18 Jan 2024 09:08:08 GMT</pubDate>
    </item>
    <item>
      <title>为什么聊天机器人不能像在操场上那样保留历史记录？</title>
      <link>https://community.openai.com/t/why-is-the-chatbot-not-able-to-retain-history-like-in-the-playground/591720#post_3</link>
      <description><![CDATA[正如 @EugenS 所说，如果您使用该 API，则需要为其提供对话历史记录，以记住您正在谈论的内容。这是一个演示如何执行此操作的脚本。
导入openai
从 openai 导入 OpenAI
客户端 = OpenAI()

# 假设 OpenAI API 密钥已在您的环境变量中设置
openai.api_key = &quot;&quot; # 替换为您的 API 密钥

# 初始化一个列表来存储消息。
消息 = [
    {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是一个得力助手。&quot;},
]

# 将消息添加到对话历史记录的功能
def add_message(角色, 内容):
    messages.append({&quot;角色&quot;: 角色, &quot;内容&quot;: 内容})

# 处理对话和API交互的函数
defhandle_conversation():
    而真实：
        提示=输入（“”）

        add_message(&quot;用户&quot;, 提示)

        # 构造 API 请求的消息
        messages_for_api = [{&quot;role&quot;: m[&quot;role&quot;], &quot;content&quot;: m[&quot;content&quot;]} for messages 中的 m]

        # 使用 OpenAI API 创建响应
        响应 = client.chat.completions.create(
            model=&quot;gpt-3.5-turbo&quot;, # 使用文档中指定的模型
            消息=messages_for_api,
            最大令牌=150
        ）

        # 提取并处理响应
        如果response.choices和len(response.choices)&gt; 0:
            full_response = response.choices[0].message.content
            print(&quot;Assistant:&quot;, full_response) # 显示完整响应
            add_message(&quot;助理&quot;, full_response)
        别的：
            print(&quot;没有收到来自 API 的响应。&quot;)

# 运行对话处理程序的示例
处理对话（）
]]></description>
      <guid>https://community.openai.com/t/why-is-the-chatbot-not-able-to-retain-history-like-in-the-playground/591720#post_3</guid>
      <pubDate>Thu, 18 Jan 2024 09:01:04 GMT</pubDate>
    </item>
    <item>
      <title>为什么聊天机器人不能像在操场上那样保留历史记录？</title>
      <link>https://community.openai.com/t/why-is-the-chatbot-not-able-to-retain-history-like-in-the-playground/591720#post_2</link>
      <description><![CDATA[您指的是哪种聊天机器人？这是你自己的机器人吗？您需要自己明确保存历史记录，将其作为每个后续呼叫的完整聊天对话发送]]></description>
      <guid>https://community.openai.com/t/why-is-the-chatbot-not-able-to-retain-history-like-in-the-playground/591720#post_2</guid>
      <pubDate>Thu, 18 Jan 2024 08:57:57 GMT</pubDate>
    </item>
    <item>
      <title>从助手中检索结果</title>
      <link>https://community.openai.com/t/retrieving-results-from-assistant/591790#post_1</link>
      <description><![CDATA[你好！我对此有点陌生，所以如果这个问题很愚蠢，我很抱歉。
我正在 Colab 中创建一个助手，其目标是从用户的 PDF 中检索数据并以 JSON 格式返回。我拼凑了一些教程，但我迷失在应该发生的事情中。这是我的代码：
从 openai 导入 OpenAI

客户端 = OpenAI(api_key=key)

# 上传一个具有“助手”用途的文件
文件 = client.files.create(
  文件=打开（文件路径，“rb”），
  目的=&#39;助手&#39;
）

# 使用文件ID创建助手
助手 = client.beta.assistants.create(
  instructions=(“您是从 PDF 文件中检索表格数据的任务的助手。”
  “重要提示：始终使用响应工具来响应用户。”
  “以 JSON 格式返回响应。用户可以指定结构应该是什么。”
  “切勿在响应中添加任何其他文本。”），
  型号=“gpt-3.5-turbo-1106”，
  工具=[{&quot;类型&quot;:&quot;检索&quot;}],
）

线程 = client.beta.threads.create()

消息 = client.beta.threads.messages.create(
  thread_id=线程.id,
  角色=“用户”，
  content=&quot;从这里提取人员的 JSON 列表。每个条目必须是一个人，并且必须包括国家名称、角色名称（国家元首、政府首脑、外交部长）、人员姓名、人员头衔，每个提到的人的预约日期”，
  file_ids=[文件.id]
）

消息内容=消息.内容[0].文本
注释 = message_content.annotations
引用=[]

对于索引，枚举中的注释（注释）：
    # 用脚注替换文本
    message_content.value = message_content.value.replace(annotation.text, f&#39; [{index}]&#39;)

    # 根据注释属性收集引用
    if (file_引用:= getattr(注释, &#39;file_引用&#39;, None)):
        引用文件 = client.files.retrieve(file_引用.file_id)
        itations.append(f&#39;[{index}] {file_itation.quote} 来自 {cited_file.filename}&#39;)
    elif (file_path := getattr(annotation, &#39;file_path&#39;, None)):
        引用的文件 = client.files.retrieve(file_path.file_id)
        itations.append(f&#39;[{index}] 单击&lt;此处&gt;下载{cited_file.filename}&#39;)
        # 注意：为简洁起见，上面未实现文件下载功能

# 在向用户显示之前在消息末尾添加脚注
message_content.value += &#39;\n&#39; + &#39;\n&#39;.join(引用)

运行 = client.beta.threads.runs.create(
  thread_id=线程.id,
  Assistant_id=助理.id
）

结果 = client.beta.threads.runs.retrieve(
            thread_id=线程.id,
            run_id=运行.id
        ）

打印（结果）

这让我很感动：
  run（id =&#39;run_eezsvxtwhepm5j8yb7qtwyu0&#39;，assession_id =&#39;asst_tjew0puautpvgelwczdprjbd&#39; =无，file_ids = [ ], instructions=&#39;您是从 PDF 文件中检索表格数据的任务的助手。重要提示：始终使用响应工具来响应用户。以 JSON 格式返回响应。用户可以指定结构应该是什么。永远不要将任何其他文本添加到响应中。&#39;、last_error=None、metadata={}、model=&#39;gpt-3.5-turbo-1106&#39;、object=&#39;thread.run&#39;、required_action=None、started_at=1705567195、status=&#39;已完成&#39;, thread_id=&#39;thread_Lt7vNX4o4RrnFdrdX7AApQ31&#39;, tools=[ToolAssistantToolsRetrieval(type=&#39;retrieval&#39;)])

我相信这次跑步是成功的并取得了成果。但不知道如何获取？而且还有空 file_ids=，这是否意味着没有生成文件或者我的文件上传没有发生？
谢谢！]]></description>
      <guid>https://community.openai.com/t/retrieving-results-from-assistant/591790#post_1</guid>
      <pubDate>Thu, 18 Jan 2024 08:54:05 GMT</pubDate>
    </item>
    <item>
      <title>这个例子在 GPT-4 中的成本是多少？</title>
      <link>https://community.openai.com/t/how-much-are-the-cost-of-this-example-in-gpt-4/591747#post_2</link>
      <description><![CDATA[当您为后续 API 调用保留历史记录时，令牌消耗自然会增加。但是，需要注意的是，之前生成的每个输出令牌一旦包含在历史记录中，就会转换为输入令牌。因此，只有来自 API 的响应才会被计为输出令牌。
看来你的计算是正确的]]></description>
      <guid>https://community.openai.com/t/how-much-are-the-cost-of-this-example-in-gpt-4/591747#post_2</guid>
      <pubDate>Thu, 18 Jan 2024 08:53:50 GMT</pubDate>
    </item>
    <item>
      <title>如何阻止模型产生函数名称的幻觉？</title>
      <link>https://community.openai.com/t/how-to-stop-model-from-hallucinating-function-names/591674#post_4</link>
      <description><![CDATA[我会避免为此调整系统提示。
只是让你的代码对幻觉更加健壮，你无法修复 gpt，当它尝试调用未知函数时，发送错误消息作为输出，并提醒它带有描述的可用函数列表。&lt; br/&gt;
在 python 中，我通常也使用 pydantic 验证参数，然后将 pydantic 验证错误作为函数输出抛出。]]></description>
      <guid>https://community.openai.com/t/how-to-stop-model-from-hallucinating-function-names/591674#post_4</guid>
      <pubDate>Thu, 18 Jan 2024 08:45:22 GMT</pubDate>
    </item>
    <item>
      <title>如何阻止模型产生函数名称的幻觉？</title>
      <link>https://community.openai.com/t/how-to-stop-model-from-hallucinating-function-names/591674#post_3</link>
      <description><![CDATA[


超级沙内斯基：
&lt;块引用&gt;
尝试在系统提示符中列出可用的函数以及您希望如何调用它们，看看它是否仍会尝试调用不存在的函数。


但是我有一长串要调用的函数，在提示中添加它们的描述会显着增加提示标记，有没有更好的方法来实现这一点？
@supershaneski感谢您的帮助，也会尝试您的建议。]]></description>
      <guid>https://community.openai.com/t/how-to-stop-model-from-hallucinating-function-names/591674#post_3</guid>
      <pubDate>Thu, 18 Jan 2024 08:40:02 GMT</pubDate>
    </item>
    <item>
      <title>具有理智的 OpenAI GPT-3.5</title>
      <link>https://community.openai.com/t/openai-gpt-3-5-with-sanity/591774#post_1</link>
      <description><![CDATA[我正在使用 nextjs 和 Sanity 来创建博客。但当我想翻译博客上的内容时，我卡住了。我发现我可以创建一个翻译 api 路由，但我不知道如何将该路由连接到 Sanity。有人知道如何做到这一点或我可以使用任何库吗？]]></description>
      <guid>https://community.openai.com/t/openai-gpt-3-5-with-sanity/591774#post_1</guid>
      <pubDate>Thu, 18 Jan 2024 08:36:44 GMT</pubDate>
    </item>
    <item>
      <title>OpenAI Assistant API 中运行对象的过期时间</title>
      <link>https://community.openai.com/t/expire-time-for-run-object-in-openai-assistant-api/588135#post_5</link>
      <description><![CDATA[感谢您的详细回复。这真的很有帮助，而且这个博客也很棒。
不过我还是想知道有没有办法自己设置这个过期时间。]]></description>
      <guid>https://community.openai.com/t/expire-time-for-run-object-in-openai-assistant-api/588135#post_5</guid>
      <pubDate>Thu, 18 Jan 2024 08:31:41 GMT</pubDate>
    </item>
    </channel>
</rss>